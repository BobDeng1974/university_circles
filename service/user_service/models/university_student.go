// Code generated by SQLBoiler (https://github.com/volatiletech/sqlboiler). DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package user

import (
	"context"
	"database/sql"
	"fmt"
	"reflect"
	"strconv"
	"strings"
	"sync"
	"time"

	"github.com/pkg/errors"
	"github.com/volatiletech/null"
	"github.com/volatiletech/sqlboiler/boil"
	"github.com/volatiletech/sqlboiler/queries"
	"github.com/volatiletech/sqlboiler/queries/qm"
	"github.com/volatiletech/sqlboiler/queries/qmhelper"
	"github.com/volatiletech/sqlboiler/strmangle"
)

// UStudent is an object representing the database table.
type UStudent struct {
	ID             uint        `boil:"id" json:"id" toml:"id" yaml:"id"`
	UID            string      `boil:"uid" json:"uid" toml:"uid" yaml:"uid"`
	StuNo          string      `boil:"stu_no" json:"stu_no" toml:"stu_no" yaml:"stu_no"`
	Password       string      `boil:"password" json:"password" toml:"password" yaml:"password"`
	RealName       string      `boil:"real_name" json:"real_name" toml:"real_name" yaml:"real_name"`
	ScreenName     string      `boil:"screen_name" json:"screen_name" toml:"screen_name" yaml:"screen_name"`
	IDCardNumber   string      `boil:"id_card_number" json:"id_card_number" toml:"id_card_number" yaml:"id_card_number"`
	Gender         string      `boil:"gender" json:"gender" toml:"gender" yaml:"gender"`
	Phone          string      `boil:"phone" json:"phone" toml:"phone" yaml:"phone"`
	Email          string      `boil:"email" json:"email" toml:"email" yaml:"email"`
	Birthday       string      `boil:"birthday" json:"birthday" toml:"birthday" yaml:"birthday"`
	Zodiac         string      `boil:"zodiac" json:"zodiac" toml:"zodiac" yaml:"zodiac"`
	Bio            string      `boil:"bio" json:"bio" toml:"bio" yaml:"bio"`
	Address        string      `boil:"address" json:"address" toml:"address" yaml:"address"`
	UniversityID   int         `boil:"university_id" json:"university_id" toml:"university_id" yaml:"university_id"`
	CollegeID      int         `boil:"college_id" json:"college_id" toml:"college_id" yaml:"college_id"`
	ProfessionID   int         `boil:"profession_id" json:"profession_id" toml:"profession_id" yaml:"profession_id"`
	ClassID        int         `boil:"class_id" json:"class_id" toml:"class_id" yaml:"class_id"`
	EntryDate      time.Time   `boil:"entry_date" json:"entry_date" toml:"entry_date" yaml:"entry_date"`
	GraduationDate time.Time   `boil:"graduation_date" json:"graduation_date" toml:"graduation_date" yaml:"graduation_date"`
	IsVerified     int8        `boil:"isVerified" json:"isVerified" toml:"isVerified" yaml:"isVerified"`
	VerifyMessage  string      `boil:"verifyMessage" json:"verifyMessage" toml:"verifyMessage" yaml:"verifyMessage"`
	Deleted        int8        `boil:"deleted" json:"deleted" toml:"deleted" yaml:"deleted"`
	CreatedUser    null.String `boil:"created_user" json:"created_user,omitempty" toml:"created_user" yaml:"created_user,omitempty"`
	CreatedAt      time.Time   `boil:"createdAt" json:"createdAt" toml:"createdAt" yaml:"createdAt"`
	UpdatedAt      time.Time   `boil:"updatedAt" json:"updatedAt" toml:"updatedAt" yaml:"updatedAt"`
	Avatar         string      `boil:"avatar" json:"avatar" toml:"avatar" yaml:"avatar"`
	Mid            int64       `boil:"mid" json:"mid" toml:"mid" yaml:"mid"`
	ForbiStranger  int8        `boil:"forbi_stranger" json:"forbi_stranger" toml:"forbi_stranger" yaml:"forbi_stranger"`
	VerifyImage    string      `boil:"verify_image" json:"verify_image" toml:"verify_image" yaml:"verify_image"`

	R *uStudentR `boil:"-" json:"-" toml:"-" yaml:"-"`
	L uStudentL  `boil:"-" json:"-" toml:"-" yaml:"-"`
}

var UStudentColumns = struct {
	ID             string
	UID            string
	StuNo          string
	Password       string
	RealName       string
	ScreenName     string
	IDCardNumber   string
	Gender         string
	Phone          string
	Email          string
	Birthday       string
	Zodiac         string
	Bio            string
	Address        string
	UniversityID   string
	CollegeID      string
	ProfessionID   string
	ClassID        string
	EntryDate      string
	GraduationDate string
	IsVerified     string
	VerifyMessage  string
	Deleted        string
	CreatedUser    string
	CreatedAt      string
	UpdatedAt      string
	Avatar         string
	Mid            string
	ForbiStranger  string
	VerifyImage    string
}{
	ID:             "id",
	UID:            "uid",
	StuNo:          "stu_no",
	Password:       "password",
	RealName:       "real_name",
	ScreenName:     "screen_name",
	IDCardNumber:   "id_card_number",
	Gender:         "gender",
	Phone:          "phone",
	Email:          "email",
	Birthday:       "birthday",
	Zodiac:         "zodiac",
	Bio:            "bio",
	Address:        "address",
	UniversityID:   "university_id",
	CollegeID:      "college_id",
	ProfessionID:   "profession_id",
	ClassID:        "class_id",
	EntryDate:      "entry_date",
	GraduationDate: "graduation_date",
	IsVerified:     "isVerified",
	VerifyMessage:  "verifyMessage",
	Deleted:        "deleted",
	CreatedUser:    "created_user",
	CreatedAt:      "createdAt",
	UpdatedAt:      "updatedAt",
	Avatar:         "avatar",
	Mid:            "mid",
	ForbiStranger:  "forbi_stranger",
	VerifyImage:    "verify_image",
}

// Generated where

type whereHelperuint struct{ field string }

func (w whereHelperuint) EQ(x uint) qm.QueryMod  { return qmhelper.Where(w.field, qmhelper.EQ, x) }
func (w whereHelperuint) NEQ(x uint) qm.QueryMod { return qmhelper.Where(w.field, qmhelper.NEQ, x) }
func (w whereHelperuint) LT(x uint) qm.QueryMod  { return qmhelper.Where(w.field, qmhelper.LT, x) }
func (w whereHelperuint) LTE(x uint) qm.QueryMod { return qmhelper.Where(w.field, qmhelper.LTE, x) }
func (w whereHelperuint) GT(x uint) qm.QueryMod  { return qmhelper.Where(w.field, qmhelper.GT, x) }
func (w whereHelperuint) GTE(x uint) qm.QueryMod { return qmhelper.Where(w.field, qmhelper.GTE, x) }

type whereHelpertime_Time struct{ field string }

func (w whereHelpertime_Time) EQ(x time.Time) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.EQ, x)
}
func (w whereHelpertime_Time) NEQ(x time.Time) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.NEQ, x)
}
func (w whereHelpertime_Time) LT(x time.Time) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.LT, x)
}
func (w whereHelpertime_Time) LTE(x time.Time) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.LTE, x)
}
func (w whereHelpertime_Time) GT(x time.Time) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.GT, x)
}
func (w whereHelpertime_Time) GTE(x time.Time) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.GTE, x)
}

type whereHelperint64 struct{ field string }

func (w whereHelperint64) EQ(x int64) qm.QueryMod  { return qmhelper.Where(w.field, qmhelper.EQ, x) }
func (w whereHelperint64) NEQ(x int64) qm.QueryMod { return qmhelper.Where(w.field, qmhelper.NEQ, x) }
func (w whereHelperint64) LT(x int64) qm.QueryMod  { return qmhelper.Where(w.field, qmhelper.LT, x) }
func (w whereHelperint64) LTE(x int64) qm.QueryMod { return qmhelper.Where(w.field, qmhelper.LTE, x) }
func (w whereHelperint64) GT(x int64) qm.QueryMod  { return qmhelper.Where(w.field, qmhelper.GT, x) }
func (w whereHelperint64) GTE(x int64) qm.QueryMod { return qmhelper.Where(w.field, qmhelper.GTE, x) }

var UStudentWhere = struct {
	ID             whereHelperuint
	UID            whereHelperstring
	StuNo          whereHelperstring
	Password       whereHelperstring
	RealName       whereHelperstring
	ScreenName     whereHelperstring
	IDCardNumber   whereHelperstring
	Gender         whereHelperstring
	Phone          whereHelperstring
	Email          whereHelperstring
	Birthday       whereHelperstring
	Zodiac         whereHelperstring
	Bio            whereHelperstring
	Address        whereHelperstring
	UniversityID   whereHelperint
	CollegeID      whereHelperint
	ProfessionID   whereHelperint
	ClassID        whereHelperint
	EntryDate      whereHelpertime_Time
	GraduationDate whereHelpertime_Time
	IsVerified     whereHelperint8
	VerifyMessage  whereHelperstring
	Deleted        whereHelperint8
	CreatedUser    whereHelpernull_String
	CreatedAt      whereHelpertime_Time
	UpdatedAt      whereHelpertime_Time
	Avatar         whereHelperstring
	Mid            whereHelperint64
	ForbiStranger  whereHelperint8
	VerifyImage    whereHelperstring
}{
	ID:             whereHelperuint{field: "`university_student`.`id`"},
	UID:            whereHelperstring{field: "`university_student`.`uid`"},
	StuNo:          whereHelperstring{field: "`university_student`.`stu_no`"},
	Password:       whereHelperstring{field: "`university_student`.`password`"},
	RealName:       whereHelperstring{field: "`university_student`.`real_name`"},
	ScreenName:     whereHelperstring{field: "`university_student`.`screen_name`"},
	IDCardNumber:   whereHelperstring{field: "`university_student`.`id_card_number`"},
	Gender:         whereHelperstring{field: "`university_student`.`gender`"},
	Phone:          whereHelperstring{field: "`university_student`.`phone`"},
	Email:          whereHelperstring{field: "`university_student`.`email`"},
	Birthday:       whereHelperstring{field: "`university_student`.`birthday`"},
	Zodiac:         whereHelperstring{field: "`university_student`.`zodiac`"},
	Bio:            whereHelperstring{field: "`university_student`.`bio`"},
	Address:        whereHelperstring{field: "`university_student`.`address`"},
	UniversityID:   whereHelperint{field: "`university_student`.`university_id`"},
	CollegeID:      whereHelperint{field: "`university_student`.`college_id`"},
	ProfessionID:   whereHelperint{field: "`university_student`.`profession_id`"},
	ClassID:        whereHelperint{field: "`university_student`.`class_id`"},
	EntryDate:      whereHelpertime_Time{field: "`university_student`.`entry_date`"},
	GraduationDate: whereHelpertime_Time{field: "`university_student`.`graduation_date`"},
	IsVerified:     whereHelperint8{field: "`university_student`.`isVerified`"},
	VerifyMessage:  whereHelperstring{field: "`university_student`.`verifyMessage`"},
	Deleted:        whereHelperint8{field: "`university_student`.`deleted`"},
	CreatedUser:    whereHelpernull_String{field: "`university_student`.`created_user`"},
	CreatedAt:      whereHelpertime_Time{field: "`university_student`.`createdAt`"},
	UpdatedAt:      whereHelpertime_Time{field: "`university_student`.`updatedAt`"},
	Avatar:         whereHelperstring{field: "`university_student`.`avatar`"},
	Mid:            whereHelperint64{field: "`university_student`.`mid`"},
	ForbiStranger:  whereHelperint8{field: "`university_student`.`forbi_stranger`"},
	VerifyImage:    whereHelperstring{field: "`university_student`.`verify_image`"},
}

// UStudentRels is where relationship names are stored.
var UStudentRels = struct {
}{}

// uStudentR is where relationships are stored.
type uStudentR struct {
}

// NewStruct creates a new relationship struct
func (*uStudentR) NewStruct() *uStudentR {
	return &uStudentR{}
}

// uStudentL is where Load methods for each relationship are stored.
type uStudentL struct{}

var (
	uStudentAllColumns            = []string{"id", "uid", "stu_no", "password", "real_name", "screen_name", "id_card_number", "gender", "phone", "email", "birthday", "zodiac", "bio", "address", "university_id", "college_id", "profession_id", "class_id", "entry_date", "graduation_date", "isVerified", "verifyMessage", "deleted", "created_user", "createdAt", "updatedAt", "avatar", "mid", "forbi_stranger", "verify_image"}
	uStudentColumnsWithoutDefault = []string{"uid", "stu_no", "password", "real_name", "screen_name", "id_card_number", "phone", "email", "birthday", "zodiac", "bio", "address", "verifyMessage", "avatar", "mid", "forbi_stranger", "verify_image"}
	uStudentColumnsWithDefault    = []string{"id", "gender", "university_id", "college_id", "profession_id", "class_id", "entry_date", "graduation_date", "isVerified", "deleted", "created_user", "createdAt", "updatedAt"}
	uStudentPrimaryKeyColumns     = []string{"id"}
)

type (
	// UStudentSlice is an alias for a slice of pointers to UStudent.
	// This should generally be used opposed to []UStudent.
	UStudentSlice []*UStudent
	// UStudentHook is the signature for custom UStudent hook methods
	UStudentHook func(context.Context, boil.ContextExecutor, *UStudent) error

	uStudentQuery struct {
		*queries.Query
	}
)

// Cache for insert, update and upsert
var (
	uStudentType                 = reflect.TypeOf(&UStudent{})
	uStudentMapping              = queries.MakeStructMapping(uStudentType)
	uStudentPrimaryKeyMapping, _ = queries.BindMapping(uStudentType, uStudentMapping, uStudentPrimaryKeyColumns)
	uStudentInsertCacheMut       sync.RWMutex
	uStudentInsertCache          = make(map[string]insertCache)
	uStudentUpdateCacheMut       sync.RWMutex
	uStudentUpdateCache          = make(map[string]updateCache)
	uStudentUpsertCacheMut       sync.RWMutex
	uStudentUpsertCache          = make(map[string]insertCache)
)

var (
	// Force time package dependency for automated UpdatedAt/CreatedAt.
	_ = time.Second
	// Force qmhelper dependency for where clause generation (which doesn't
	// always happen)
	_ = qmhelper.Where
)

var uStudentBeforeInsertHooks []UStudentHook
var uStudentBeforeUpdateHooks []UStudentHook
var uStudentBeforeDeleteHooks []UStudentHook
var uStudentBeforeUpsertHooks []UStudentHook

var uStudentAfterInsertHooks []UStudentHook
var uStudentAfterSelectHooks []UStudentHook
var uStudentAfterUpdateHooks []UStudentHook
var uStudentAfterDeleteHooks []UStudentHook
var uStudentAfterUpsertHooks []UStudentHook

// doBeforeInsertHooks executes all "before insert" hooks.
func (o *UStudent) doBeforeInsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range uStudentBeforeInsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeUpdateHooks executes all "before Update" hooks.
func (o *UStudent) doBeforeUpdateHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range uStudentBeforeUpdateHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeDeleteHooks executes all "before Delete" hooks.
func (o *UStudent) doBeforeDeleteHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range uStudentBeforeDeleteHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeUpsertHooks executes all "before Upsert" hooks.
func (o *UStudent) doBeforeUpsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range uStudentBeforeUpsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterInsertHooks executes all "after Insert" hooks.
func (o *UStudent) doAfterInsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range uStudentAfterInsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterSelectHooks executes all "after Select" hooks.
func (o *UStudent) doAfterSelectHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range uStudentAfterSelectHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterUpdateHooks executes all "after Update" hooks.
func (o *UStudent) doAfterUpdateHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range uStudentAfterUpdateHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterDeleteHooks executes all "after Delete" hooks.
func (o *UStudent) doAfterDeleteHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range uStudentAfterDeleteHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterUpsertHooks executes all "after Upsert" hooks.
func (o *UStudent) doAfterUpsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range uStudentAfterUpsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// AddUStudentHook registers your hook function for all future operations.
func AddUStudentHook(hookPoint boil.HookPoint, uStudentHook UStudentHook) {
	switch hookPoint {
	case boil.BeforeInsertHook:
		uStudentBeforeInsertHooks = append(uStudentBeforeInsertHooks, uStudentHook)
	case boil.BeforeUpdateHook:
		uStudentBeforeUpdateHooks = append(uStudentBeforeUpdateHooks, uStudentHook)
	case boil.BeforeDeleteHook:
		uStudentBeforeDeleteHooks = append(uStudentBeforeDeleteHooks, uStudentHook)
	case boil.BeforeUpsertHook:
		uStudentBeforeUpsertHooks = append(uStudentBeforeUpsertHooks, uStudentHook)
	case boil.AfterInsertHook:
		uStudentAfterInsertHooks = append(uStudentAfterInsertHooks, uStudentHook)
	case boil.AfterSelectHook:
		uStudentAfterSelectHooks = append(uStudentAfterSelectHooks, uStudentHook)
	case boil.AfterUpdateHook:
		uStudentAfterUpdateHooks = append(uStudentAfterUpdateHooks, uStudentHook)
	case boil.AfterDeleteHook:
		uStudentAfterDeleteHooks = append(uStudentAfterDeleteHooks, uStudentHook)
	case boil.AfterUpsertHook:
		uStudentAfterUpsertHooks = append(uStudentAfterUpsertHooks, uStudentHook)
	}
}

// One returns a single uStudent record from the query.
func (q uStudentQuery) One(ctx context.Context, exec boil.ContextExecutor) (*UStudent, error) {
	o := &UStudent{}

	queries.SetLimit(q.Query, 1)

	err := q.Bind(ctx, exec, o)
	if err != nil {
		if errors.Cause(err) == sql.ErrNoRows {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "user: failed to execute a one query for university_student")
	}

	if err := o.doAfterSelectHooks(ctx, exec); err != nil {
		return o, err
	}

	return o, nil
}

// All returns all UStudent records from the query.
func (q uStudentQuery) All(ctx context.Context, exec boil.ContextExecutor) (UStudentSlice, error) {
	var o []*UStudent

	err := q.Bind(ctx, exec, &o)
	if err != nil {
		return nil, errors.Wrap(err, "user: failed to assign all query results to UStudent slice")
	}

	if len(uStudentAfterSelectHooks) != 0 {
		for _, obj := range o {
			if err := obj.doAfterSelectHooks(ctx, exec); err != nil {
				return o, err
			}
		}
	}

	return o, nil
}

// Count returns the count of all UStudent records in the query.
func (q uStudentQuery) Count(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return 0, errors.Wrap(err, "user: failed to count university_student rows")
	}

	return count, nil
}

// Exists checks if the row exists in the table.
func (q uStudentQuery) Exists(ctx context.Context, exec boil.ContextExecutor) (bool, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)
	queries.SetLimit(q.Query, 1)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return false, errors.Wrap(err, "user: failed to check if university_student exists")
	}

	return count > 0, nil
}

// UStudents retrieves all the records using an executor.
func UStudents(mods ...qm.QueryMod) uStudentQuery {
	mods = append(mods, qm.From("`university_student`"))
	return uStudentQuery{NewQuery(mods...)}
}

// FindUStudent retrieves a single record by ID with an executor.
// If selectCols is empty Find will return all columns.
func FindUStudent(ctx context.Context, exec boil.ContextExecutor, iD uint, selectCols ...string) (*UStudent, error) {
	uStudentObj := &UStudent{}

	sel := "*"
	if len(selectCols) > 0 {
		sel = strings.Join(strmangle.IdentQuoteSlice(dialect.LQ, dialect.RQ, selectCols), ",")
	}
	query := fmt.Sprintf(
		"select %s from `university_student` where `id`=?", sel,
	)

	q := queries.Raw(query, iD)

	err := q.Bind(ctx, exec, uStudentObj)
	if err != nil {
		if errors.Cause(err) == sql.ErrNoRows {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "user: unable to select from university_student")
	}

	return uStudentObj, nil
}

// Insert a single record using an executor.
// See boil.Columns.InsertColumnSet documentation to understand column list inference for inserts.
func (o *UStudent) Insert(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) error {
	if o == nil {
		return errors.New("user: no university_student provided for insertion")
	}

	var err error

	if err := o.doBeforeInsertHooks(ctx, exec); err != nil {
		return err
	}

	nzDefaults := queries.NonZeroDefaultSet(uStudentColumnsWithDefault, o)

	key := makeCacheKey(columns, nzDefaults)
	uStudentInsertCacheMut.RLock()
	cache, cached := uStudentInsertCache[key]
	uStudentInsertCacheMut.RUnlock()

	if !cached {
		wl, returnColumns := columns.InsertColumnSet(
			uStudentAllColumns,
			uStudentColumnsWithDefault,
			uStudentColumnsWithoutDefault,
			nzDefaults,
		)

		cache.valueMapping, err = queries.BindMapping(uStudentType, uStudentMapping, wl)
		if err != nil {
			return err
		}
		cache.retMapping, err = queries.BindMapping(uStudentType, uStudentMapping, returnColumns)
		if err != nil {
			return err
		}
		if len(wl) != 0 {
			cache.query = fmt.Sprintf("INSERT INTO `university_student` (`%s`) %%sVALUES (%s)%%s", strings.Join(wl, "`,`"), strmangle.Placeholders(dialect.UseIndexPlaceholders, len(wl), 1, 1))
		} else {
			cache.query = "INSERT INTO `university_student` () VALUES ()%s%s"
		}

		var queryOutput, queryReturning string

		if len(cache.retMapping) != 0 {
			cache.retQuery = fmt.Sprintf("SELECT `%s` FROM `university_student` WHERE %s", strings.Join(returnColumns, "`,`"), strmangle.WhereClause("`", "`", 0, uStudentPrimaryKeyColumns))
		}

		cache.query = fmt.Sprintf(cache.query, queryOutput, queryReturning)
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, cache.query)
		fmt.Fprintln(boil.DebugWriter, vals)
	}

	result, err := exec.ExecContext(ctx, cache.query, vals...)

	if err != nil {
		return errors.Wrap(err, "user: unable to insert into university_student")
	}

	var lastID int64
	var identifierCols []interface{}

	if len(cache.retMapping) == 0 {
		goto CacheNoHooks
	}

	lastID, err = result.LastInsertId()
	if err != nil {
		return ErrSyncFail
	}

	o.ID = uint(lastID)
	if lastID != 0 && len(cache.retMapping) == 1 && cache.retMapping[0] == uStudentMapping["ID"] {
		goto CacheNoHooks
	}

	identifierCols = []interface{}{
		o.ID,
	}

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, cache.retQuery)
		fmt.Fprintln(boil.DebugWriter, identifierCols...)
	}

	err = exec.QueryRowContext(ctx, cache.retQuery, identifierCols...).Scan(queries.PtrsFromMapping(value, cache.retMapping)...)
	if err != nil {
		return errors.Wrap(err, "user: unable to populate default values for university_student")
	}

CacheNoHooks:
	if !cached {
		uStudentInsertCacheMut.Lock()
		uStudentInsertCache[key] = cache
		uStudentInsertCacheMut.Unlock()
	}

	return o.doAfterInsertHooks(ctx, exec)
}

// Update uses an executor to update the UStudent.
// See boil.Columns.UpdateColumnSet documentation to understand column list inference for updates.
// Update does not automatically update the record in case of default values. Use .Reload() to refresh the records.
func (o *UStudent) Update(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) (int64, error) {
	var err error
	if err = o.doBeforeUpdateHooks(ctx, exec); err != nil {
		return 0, err
	}
	key := makeCacheKey(columns, nil)
	uStudentUpdateCacheMut.RLock()
	cache, cached := uStudentUpdateCache[key]
	uStudentUpdateCacheMut.RUnlock()

	if !cached {
		wl := columns.UpdateColumnSet(
			uStudentAllColumns,
			uStudentPrimaryKeyColumns,
		)

		if !columns.IsWhitelist() {
			wl = strmangle.SetComplement(wl, []string{"created_at"})
		}
		if len(wl) == 0 {
			return 0, errors.New("user: unable to update university_student, could not build whitelist")
		}

		cache.query = fmt.Sprintf("UPDATE `university_student` SET %s WHERE %s",
			strmangle.SetParamNames("`", "`", 0, wl),
			strmangle.WhereClause("`", "`", 0, uStudentPrimaryKeyColumns),
		)
		cache.valueMapping, err = queries.BindMapping(uStudentType, uStudentMapping, append(wl, uStudentPrimaryKeyColumns...))
		if err != nil {
			return 0, err
		}
	}

	values := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), cache.valueMapping)

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, cache.query)
		fmt.Fprintln(boil.DebugWriter, values)
	}

	var result sql.Result
	result, err = exec.ExecContext(ctx, cache.query, values...)
	if err != nil {
		return 0, errors.Wrap(err, "user: unable to update university_student row")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "user: failed to get rows affected by update for university_student")
	}

	if !cached {
		uStudentUpdateCacheMut.Lock()
		uStudentUpdateCache[key] = cache
		uStudentUpdateCacheMut.Unlock()
	}

	return rowsAff, o.doAfterUpdateHooks(ctx, exec)
}

// UpdateAll updates all rows with the specified column values.
func (q uStudentQuery) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error) {
	queries.SetUpdate(q.Query, cols)

	result, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return 0, errors.Wrap(err, "user: unable to update all for university_student")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "user: unable to retrieve rows affected for university_student")
	}

	return rowsAff, nil
}

// UpdateAll updates all rows with the specified column values, using an executor.
func (o UStudentSlice) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error) {
	ln := int64(len(o))
	if ln == 0 {
		return 0, nil
	}

	if len(cols) == 0 {
		return 0, errors.New("user: update all requires at least one column argument")
	}

	colNames := make([]string, len(cols))
	args := make([]interface{}, len(cols))

	i := 0
	for name, value := range cols {
		colNames[i] = name
		args[i] = value
		i++
	}

	// Append all of the primary key values for each column
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), uStudentPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := fmt.Sprintf("UPDATE `university_student` SET %s WHERE %s",
		strmangle.SetParamNames("`", "`", 0, colNames),
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 0, uStudentPrimaryKeyColumns, len(o)))

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, sql)
		fmt.Fprintln(boil.DebugWriter, args...)
	}

	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "user: unable to update all in uStudent slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "user: unable to retrieve rows affected all in update all uStudent")
	}
	return rowsAff, nil
}

var mySQLUStudentUniqueColumns = []string{
	"id",
}

// Upsert attempts an insert using an executor, and does an update or ignore on conflict.
// See boil.Columns documentation for how to properly use updateColumns and insertColumns.
func (o *UStudent) Upsert(ctx context.Context, exec boil.ContextExecutor, updateColumns, insertColumns boil.Columns) error {
	if o == nil {
		return errors.New("user: no university_student provided for upsert")
	}

	if err := o.doBeforeUpsertHooks(ctx, exec); err != nil {
		return err
	}

	nzDefaults := queries.NonZeroDefaultSet(uStudentColumnsWithDefault, o)
	nzUniques := queries.NonZeroDefaultSet(mySQLUStudentUniqueColumns, o)

	if len(nzUniques) == 0 {
		return errors.New("cannot upsert with a table that cannot conflict on a unique column")
	}

	// Build cache key in-line uglily - mysql vs psql problems
	buf := strmangle.GetBuffer()
	buf.WriteString(strconv.Itoa(updateColumns.Kind))
	for _, c := range updateColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	buf.WriteString(strconv.Itoa(insertColumns.Kind))
	for _, c := range insertColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	for _, c := range nzDefaults {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	for _, c := range nzUniques {
		buf.WriteString(c)
	}
	key := buf.String()
	strmangle.PutBuffer(buf)

	uStudentUpsertCacheMut.RLock()
	cache, cached := uStudentUpsertCache[key]
	uStudentUpsertCacheMut.RUnlock()

	var err error

	if !cached {
		insert, ret := insertColumns.InsertColumnSet(
			uStudentAllColumns,
			uStudentColumnsWithDefault,
			uStudentColumnsWithoutDefault,
			nzDefaults,
		)
		update := updateColumns.UpdateColumnSet(
			uStudentAllColumns,
			uStudentPrimaryKeyColumns,
		)

		if len(update) == 0 {
			return errors.New("user: unable to upsert university_student, could not build update column list")
		}

		ret = strmangle.SetComplement(ret, nzUniques)
		cache.query = buildUpsertQueryMySQL(dialect, "university_student", update, insert)
		cache.retQuery = fmt.Sprintf(
			"SELECT %s FROM `university_student` WHERE %s",
			strings.Join(strmangle.IdentQuoteSlice(dialect.LQ, dialect.RQ, ret), ","),
			strmangle.WhereClause("`", "`", 0, nzUniques),
		)

		cache.valueMapping, err = queries.BindMapping(uStudentType, uStudentMapping, insert)
		if err != nil {
			return err
		}
		if len(ret) != 0 {
			cache.retMapping, err = queries.BindMapping(uStudentType, uStudentMapping, ret)
			if err != nil {
				return err
			}
		}
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)
	var returns []interface{}
	if len(cache.retMapping) != 0 {
		returns = queries.PtrsFromMapping(value, cache.retMapping)
	}

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, cache.query)
		fmt.Fprintln(boil.DebugWriter, vals)
	}

	result, err := exec.ExecContext(ctx, cache.query, vals...)

	if err != nil {
		return errors.Wrap(err, "user: unable to upsert for university_student")
	}

	var lastID int64
	var uniqueMap []uint64
	var nzUniqueCols []interface{}

	if len(cache.retMapping) == 0 {
		goto CacheNoHooks
	}

	lastID, err = result.LastInsertId()
	if err != nil {
		return ErrSyncFail
	}

	o.ID = uint(lastID)
	if lastID != 0 && len(cache.retMapping) == 1 && cache.retMapping[0] == uStudentMapping["id"] {
		goto CacheNoHooks
	}

	uniqueMap, err = queries.BindMapping(uStudentType, uStudentMapping, nzUniques)
	if err != nil {
		return errors.Wrap(err, "user: unable to retrieve unique values for university_student")
	}
	nzUniqueCols = queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), uniqueMap)

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, cache.retQuery)
		fmt.Fprintln(boil.DebugWriter, nzUniqueCols...)
	}

	err = exec.QueryRowContext(ctx, cache.retQuery, nzUniqueCols...).Scan(returns...)
	if err != nil {
		return errors.Wrap(err, "user: unable to populate default values for university_student")
	}

CacheNoHooks:
	if !cached {
		uStudentUpsertCacheMut.Lock()
		uStudentUpsertCache[key] = cache
		uStudentUpsertCacheMut.Unlock()
	}

	return o.doAfterUpsertHooks(ctx, exec)
}

// Delete deletes a single UStudent record with an executor.
// Delete will match against the primary key column to find the record to delete.
func (o *UStudent) Delete(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if o == nil {
		return 0, errors.New("user: no UStudent provided for delete")
	}

	if err := o.doBeforeDeleteHooks(ctx, exec); err != nil {
		return 0, err
	}

	args := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), uStudentPrimaryKeyMapping)
	sql := "DELETE FROM `university_student` WHERE `id`=?"

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, sql)
		fmt.Fprintln(boil.DebugWriter, args...)
	}

	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "user: unable to delete from university_student")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "user: failed to get rows affected by delete for university_student")
	}

	if err := o.doAfterDeleteHooks(ctx, exec); err != nil {
		return 0, err
	}

	return rowsAff, nil
}

// DeleteAll deletes all matching rows.
func (q uStudentQuery) DeleteAll(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if q.Query == nil {
		return 0, errors.New("user: no uStudentQuery provided for delete all")
	}

	queries.SetDelete(q.Query)

	result, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return 0, errors.Wrap(err, "user: unable to delete all from university_student")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "user: failed to get rows affected by deleteall for university_student")
	}

	return rowsAff, nil
}

// DeleteAll deletes all rows in the slice, using an executor.
func (o UStudentSlice) DeleteAll(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if len(o) == 0 {
		return 0, nil
	}

	if len(uStudentBeforeDeleteHooks) != 0 {
		for _, obj := range o {
			if err := obj.doBeforeDeleteHooks(ctx, exec); err != nil {
				return 0, err
			}
		}
	}

	var args []interface{}
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), uStudentPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "DELETE FROM `university_student` WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 0, uStudentPrimaryKeyColumns, len(o))

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, sql)
		fmt.Fprintln(boil.DebugWriter, args)
	}

	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "user: unable to delete all from uStudent slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "user: failed to get rows affected by deleteall for university_student")
	}

	if len(uStudentAfterDeleteHooks) != 0 {
		for _, obj := range o {
			if err := obj.doAfterDeleteHooks(ctx, exec); err != nil {
				return 0, err
			}
		}
	}

	return rowsAff, nil
}

// Reload refetches the object from the database
// using the primary keys with an executor.
func (o *UStudent) Reload(ctx context.Context, exec boil.ContextExecutor) error {
	ret, err := FindUStudent(ctx, exec, o.ID)
	if err != nil {
		return err
	}

	*o = *ret
	return nil
}

// ReloadAll refetches every row with matching primary key column values
// and overwrites the original object slice with the newly updated slice.
func (o *UStudentSlice) ReloadAll(ctx context.Context, exec boil.ContextExecutor) error {
	if o == nil || len(*o) == 0 {
		return nil
	}

	slice := UStudentSlice{}
	var args []interface{}
	for _, obj := range *o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), uStudentPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "SELECT `university_student`.* FROM `university_student` WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 0, uStudentPrimaryKeyColumns, len(*o))

	q := queries.Raw(sql, args...)

	err := q.Bind(ctx, exec, &slice)
	if err != nil {
		return errors.Wrap(err, "user: unable to reload all in UStudentSlice")
	}

	*o = slice

	return nil
}

// UStudentExists checks if the UStudent row exists.
func UStudentExists(ctx context.Context, exec boil.ContextExecutor, iD uint) (bool, error) {
	var exists bool
	sql := "select exists(select 1 from `university_student` where `id`=? limit 1)"

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, sql)
		fmt.Fprintln(boil.DebugWriter, iD)
	}

	row := exec.QueryRowContext(ctx, sql, iD)

	err := row.Scan(&exists)
	if err != nil {
		return false, errors.Wrap(err, "user: unable to check if university_student exists")
	}

	return exists, nil
}
